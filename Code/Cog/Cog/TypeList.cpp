#include "CogPch.h"
#include "TypeList.h"

// The definition of this should be generated by the build tool
void RegisterExecutableTypes_Generated(TypeList* aTypeList);

void TypeList::BuildList()
{
	Internal_AddType(TypeID<CogTypeBase>::Resolve<Object>(), L"Object", &CreateObjectChunk<Object, ObjectCogTypeChunk>, nullptr);
	
	RegisterExecutableTypes_Generated(this);

	for (TypeData* type : myIDToData)
	{
		const StringView& specializationOf = type->GetSpecializationOf();

		if (specializationOf.GetLength() > 0)
		{
			if (const u16* specializationOfID = myTypeNameToID.Find(specializationOf))
			{
				CHECK(myIDToData.IsValidIndex(*specializationOfID));
				TypeData* base = myIDToData[*specializationOfID];
				CHECK(base);
				CHECK(!base->GetSpecialization());
				base->SetSpecialization(*type);
			}
			else
			{
				FATAL(L"Component % specializes an unknown type: %", type->GetName(), specializationOf);
			}
		}
	}

	for (TypeData* type : myIDToData)
	{
		if (!type->HasOutermostSpecialization())
			type->AssignOutermostSpecialization();
	}
}

const TypeData& TypeList::GetTypeDataByIndex(const u16 aTypeIndex, const bool aOutermost) const
{
	CHECK_MSG(myIDToData.IsValidIndex(aTypeIndex), L"Type index out of range");

	const TypeData* data = myIDToData[aTypeIndex];

	if (!data)
		FATAL(L"This type has not been registered");

	return aOutermost ? data->GetOutermostSpecialization() : *data;
}

TypeData& TypeList::Internal_AddGenericType(const TypeID<CogTypeBase>& aTypeID, const StringView& aTypeName)
{
	CHECK(aTypeName.GetLength() > 0);

	const u16 typeIndex = aTypeID.GetUnderlyingInteger();
	myTypeNameToID.Add(aTypeName, typeIndex);

	if (typeIndex >= myIDToData.GetLength())
		myIDToData.Resize(typeIndex + 1);

	myIDToData[typeIndex] = MakeUnique<TypeData>();
	TypeData& data = *myIDToData[typeIndex];

	if (data.GetName().GetLength() > 0)
		FATAL("Double registration on type ", aTypeName);

	data.SetName(aTypeName);

	return data;
}

TypeData& TypeList::Internal_AddType(const TypeID<CogTypeBase>& aTypeID, const StringView& aTypeName, UniquePtr<CogTypeChunk>(*aFactoryAllocator)(), nullptr_t)
{
	TypeData& data = Internal_AddGenericType(aTypeID, aTypeName);
	data.SetFactoryAllocator(aFactoryAllocator);
	return data;
}

void TypeList::Internal_AddSpecialization(const StringView& aBaseName, const TypeID<CogTypeBase>& aTypeID, const StringView& aSpecializationName, UniquePtr<CogTypeChunk>(*aFactoryAllocator)(), nullptr_t)
{
	TypeData& typeData = Internal_AddType(aTypeID, aSpecializationName, aFactoryAllocator, nullptr);
	typeData.SetSpecializationOf(aBaseName);
}

TypeData& TypeList::Internal_AddSingleton(const TypeID<CogTypeBase>& aTypeID, const StringView& aTypeName, UniquePtr<Singleton>(*aSingletonAllocator)(), nullptr_t)
{
	TypeData& data = Internal_AddGenericType(aTypeID, aTypeName);
	data.SetSingletonAllocator(aSingletonAllocator);
	return data;
}

void TypeList::Internal_AddSingletonSpecialization(const StringView& aBaseName, const TypeID<CogTypeBase>& aTypeID, const StringView& aSpecializationName, UniquePtr<Singleton>(*aSingletonAllocator)(), nullptr_t)
{
	TypeData& typeData = Internal_AddSingleton(aTypeID, aSpecializationName, aSingletonAllocator, nullptr);
	typeData.SetSpecializationOf(aBaseName);
}
